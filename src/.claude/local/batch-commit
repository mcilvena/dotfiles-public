#!/bin/bash

# Batch commit script - intelligently groups unstaged changes into logical commits
# Uses Claude to analyze changes and create appropriate commit groups
# Delegates actual committing to single-commit script for consistency

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Claude CLI path
CLAUDE="${HOME}/.claude/local/claude"
SINGLE_COMMIT="${HOME}/.claude/local/single-commit"

# Functions
log_error() {
    echo -e "❌ ${RED}ERROR${NC}: $1" >&2
}

log_warning() {
    echo -e "⚠️  ${YELLOW}WARNING${NC}: $1" >&2
}

log_success() {
    echo -e "✅ ${GREEN}$1${NC}" >&2
}

log_info() {
    echo -e "ℹ️  ${CYAN}$1${NC}" >&2
}

log_step() {
    echo -e "🔄 ${BLUE}$1${NC}" >&2
}

# Check if git repo
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    log_error "Not a git repository"
    exit 1
fi

# Initialize counters
TOTAL_COMMITS=0
ITERATION=0

# Loop until all changes are committed
while true; do
    ITERATION=$((ITERATION + 1))

    # Check if there are unstaged changes
    if ! git diff --quiet; then
        UNSTAGED_CHANGES=true
    else
        UNSTAGED_CHANGES=false
    fi

    # Check if there are untracked files
    UNTRACKED_FILES=$(git ls-files --others --exclude-standard)

    if [ "$UNSTAGED_CHANGES" = false ] && [ -z "$UNTRACKED_FILES" ]; then
        if [ $ITERATION -eq 1 ]; then
            log_warning "No unstaged changes or untracked files to commit"
        else
            log_success "All changes have been committed in $TOTAL_COMMITS total commit(s) across $((ITERATION - 1)) iteration(s)!"
        fi
        exit 0
    fi

    if [ $ITERATION -gt 1 ]; then
        echo "" >&2
        log_info "Starting iteration $ITERATION..."
        echo "" >&2
    fi

    # Get the diff of all changes (both unstaged and untracked)
    log_step "Analyzing changes..."
    DIFF_OUTPUT=$(git diff)
    UNTRACKED_CONTENT=""

    # Add untracked files to the analysis
    if [ -n "$UNTRACKED_FILES" ]; then
        while IFS= read -r file; do
            if [ -f "$file" ]; then
                UNTRACKED_CONTENT="${UNTRACKED_CONTENT}
==== NEW FILE: $file ====
$(cat "$file")
"
            fi
        done <<< "$UNTRACKED_FILES"
    fi

    # Combine all changes
    FULL_DIFF="${DIFF_OUTPUT}
${UNTRACKED_CONTENT}"

    # Ask Claude to analyze and group the changes
    log_step "Asking Claude to group changes into logical commits..."

    ANALYSIS=$($CLAUDE "Analyze the following git changes and group them into logical commits. Consider:
- Domain/feature area (API, database, frontend, infrastructure, tests, docs, config)
- Type of change (feat, refactor, fix, test, docs, chore)
- Related files that should be committed together
- Files that are clearly independent and should be separate commits

For EACH logical group, output EXACTLY this format (no extra text):
---GROUP---
FILES:
path/to/file1.ext
path/to/file2.ext
---END---

Rules:
- Output ONLY the groups in the format above
- No explanations, preamble, or additional text
- Each GROUP must have at least one file in FILES section
- If there's only ONE logical group, still use the format above
- Be specific with file paths - use exact paths from the diff

Changes to analyze:
$FULL_DIFF" 2>/dev/null)

    # Check if we got valid output
    if [ -z "$ANALYSIS" ]; then
        log_error "Claude couldn't analyze the changes. Creating a single commit..."
        # Fallback: stage everything and create one commit
        git add -A
        $SINGLE_COMMIT
        exit $?
    fi

    # Parse and process groups
    COMMITS_CREATED=0
    CURRENT_GROUP=""
    READING_FILES=false

    while IFS= read -r line; do
        if [ "$line" = "---GROUP---" ]; then
            CURRENT_GROUP="active"
            READING_FILES=false
            FILES=()
            continue
        fi

        if [ "$line" = "---END---" ]; then
            if [ "$CURRENT_GROUP" = "active" ] && [ ${#FILES[@]} -gt 0 ]; then
                COMMITS_CREATED=$((COMMITS_CREATED + 1))
                TOTAL_COMMITS=$((TOTAL_COMMITS + 1))
                log_step "Processing commit group $COMMITS_CREATED (total: $TOTAL_COMMITS)..."

                # Stage only the files in this group
                STAGED_COUNT=0
                for file in "${FILES[@]}"; do
                    # Skip empty lines
                    if [ -z "$file" ]; then
                        continue
                    fi

                    if [ -f "$file" ] || git ls-files --others --exclude-standard | grep -Fxq "$file"; then
                        git add "$file" 2>/dev/null && {
                            log_info "  Staged: $file"
                            STAGED_COUNT=$((STAGED_COUNT + 1))
                        }
                    fi
                done

                if [ $STAGED_COUNT -eq 0 ]; then
                    log_warning "  No valid files staged for this group, skipping..."
                else
                    # Use single-commit to create the commit
                    if $SINGLE_COMMIT 2>&1; then
                        LAST_COMMIT=$(git log -1 --pretty=format:"%s")
                        log_success "Created commit $TOTAL_COMMITS: $LAST_COMMIT"
                    else
                        log_error "Failed to create commit for group $COMMITS_CREATED"
                        # Unstage the files
                        git reset HEAD -- . 2>/dev/null
                    fi
                fi

                echo "" >&2
            fi

            CURRENT_GROUP=""
            READING_FILES=false
            FILES=()
            continue
        fi

        if [ "$CURRENT_GROUP" = "active" ]; then
            if [ "$line" = "FILES:" ]; then
                READING_FILES=true
                continue
            fi

            if [ "$READING_FILES" = true ] && [ -n "$line" ]; then
                FILES+=("$line")
            fi
        fi
    done <<< "$ANALYSIS"

    # Check if any commits were created in this iteration
    if [ $COMMITS_CREATED -eq 0 ]; then
        log_warning "No commits were created in iteration $ITERATION"
        exit 1
    fi

    log_info "Completed iteration $ITERATION with $COMMITS_CREATED commit(s)"

    # Loop will continue if there are still unstaged changes
done
