#!/usr/bin/env bash

# Batch commit script - intelligently groups unstaged changes into logical commits
# Uses Claude to analyze changes and create appropriate commit groups
# Delegates actual committing to single-commit script for consistency

set -e

# Constants
MAX_ITERATIONS=20
MAX_FILE_SIZE=$((1024 * 1024))  # 1MB per file
MAX_TOTAL_SIZE=$((10 * 1024 * 1024))  # 10MB total diff

# Colors for output (only if terminal)
if [ -t 2 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    CYAN=''
    NC=''
fi

# Claude CLI path - configurable via environment variable
CLAUDE="${CLAUDE_CLI_PATH:-${HOME}/.claude/local/claude}"
SINGLE_COMMIT="${HOME}/.local/bin/single-commit"

# Functions
log_error() {
    echo -e "${RED}ERROR${NC}: $1" >&2
}

log_warning() {
    echo -e "${YELLOW}WARNING${NC}: $1" >&2
}

log_success() {
    echo -e "${GREEN}$1${NC}" >&2
}

log_info() {
    echo -e "${CYAN}$1${NC}" >&2
}

log_step() {
    echo -e "${BLUE}$1${NC}" >&2
}

# Helper to check if file is binary
is_binary() {
    local file="$1"
    if file "$file" | grep -q "text"; then
        return 1  # Not binary
    else
        return 0  # Is binary
    fi
}

# Validate Claude CLI exists
if [ ! -f "$CLAUDE" ]; then
    log_error "Claude CLI not found at: $CLAUDE"
    log_error "Set CLAUDE_CLI_PATH environment variable or install Claude CLI"
    exit 1
fi

if [ ! -x "$CLAUDE" ]; then
    log_error "Claude CLI is not executable: $CLAUDE"
    exit 1
fi

# Validate single-commit script exists
if [ ! -f "$SINGLE_COMMIT" ]; then
    log_error "single-commit script not found at: $SINGLE_COMMIT"
    exit 1
fi

if [ ! -x "$SINGLE_COMMIT" ]; then
    log_error "single-commit script is not executable: $SINGLE_COMMIT"
    exit 1
fi

# Check if git repo
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    log_error "Not a git repository"
    exit 1
fi

# Initialize counters
TOTAL_COMMITS=0
ITERATION=0

# Loop until all changes are committed
while true; do
    ITERATION=$((ITERATION + 1))

    # Check iteration limit
    if [ $ITERATION -gt $MAX_ITERATIONS ]; then
        log_error "Maximum iterations ($MAX_ITERATIONS) reached. Stopping to prevent infinite loop."
        log_info "Created $TOTAL_COMMITS commit(s) before stopping"
        exit 1
    fi

    # Check if there are unstaged changes
    if ! git diff --quiet; then
        UNSTAGED_CHANGES=true
    else
        UNSTAGED_CHANGES=false
    fi

    # Check if there are untracked files
    UNTRACKED_FILES=$(git ls-files --others --exclude-standard)

    if [ "$UNSTAGED_CHANGES" = false ] && [ -z "$UNTRACKED_FILES" ]; then
        if [ $ITERATION -eq 1 ]; then
            log_warning "No unstaged changes or untracked files to commit"
        else
            log_success "All changes have been committed in $TOTAL_COMMITS total commit(s) across $((ITERATION - 1)) iteration(s)!"
        fi
        exit 0
    fi

    if [ $ITERATION -gt 1 ]; then
        echo "" >&2
        log_info "Starting iteration $ITERATION/$MAX_ITERATIONS..."
        echo "" >&2
    fi

    # Get the diff of all changes (both unstaged and untracked)
    log_step "Analyzing changes..."
    DIFF_OUTPUT=$(git diff)

    # Create a temporary file for safe content handling
    TEMP_DIFF=$(mktemp)
    trap 'rm -f "$TEMP_DIFF"' EXIT

    echo "$DIFF_OUTPUT" > "$TEMP_DIFF"
    TOTAL_SIZE=${#DIFF_OUTPUT}

    # Add untracked files to the analysis (with safety checks)
    if [ -n "$UNTRACKED_FILES" ]; then
        while IFS= read -r file; do
            # Skip if file doesn't exist (race condition)
            if [ ! -f "$file" ]; then
                log_warning "Skipping missing file: $file"
                continue
            fi

            # Check if binary
            if is_binary "$file"; then
                log_warning "Skipping binary file: $file"
                echo "==== NEW FILE (binary, skipped): $file ====" >> "$TEMP_DIFF"
                continue
            fi

            # Check file size
            FILE_SIZE=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo 0)
            if [ "$FILE_SIZE" -gt "$MAX_FILE_SIZE" ]; then
                log_warning "Skipping large file: $file (${FILE_SIZE} bytes)"
                echo "==== NEW FILE (too large, skipped): $file ====" >> "$TEMP_DIFF"
                continue
            fi

            # Check total size limit
            TOTAL_SIZE=$((TOTAL_SIZE + FILE_SIZE))
            if [ "$TOTAL_SIZE" -gt "$MAX_TOTAL_SIZE" ]; then
                log_warning "Reached total size limit, skipping remaining files"
                break
            fi

            # Safely append file content
            {
                echo ""
                echo "==== NEW FILE: $file ===="
                cat "$file"
            } >> "$TEMP_DIFF"
        done <<< "$UNTRACKED_FILES"
    fi

    # Ask Claude to analyze and group the changes
    log_step "Asking Claude to group changes into logical commits..."

    ANALYSIS=$("$CLAUDE" <<EOF
Analyze the following git changes and group them into logical commits. Consider:
- Domain/feature area (API, database, frontend, infrastructure, tests, docs, config)
- Type of change (feat, refactor, fix, test, docs, chore)
- Related files that should be committed together
- Files that are clearly independent and should be separate commits

For EACH logical group, output EXACTLY this format (no extra text):
---GROUP---
FILES:
path/to/file1.ext
path/to/file2.ext
---END---

Rules:
- Output ONLY the groups in the format above
- No explanations, preamble, or additional text
- Each GROUP must have at least one file in FILES section
- If there's only ONE logical group, still use the format above
- Be specific with file paths - use exact paths from the diff

Changes to analyze:
$(cat "$TEMP_DIFF")
EOF
)

    # Check if we got valid output
    if [ -z "$ANALYSIS" ]; then
        log_error "Claude couldn't analyze the changes"
        log_info "You may need to manually commit these changes"
        exit 1
    fi

    # Parse and process groups
    COMMITS_CREATED=0
    CURRENT_GROUP=""
    READING_FILES=false

    while IFS= read -r line; do
        if [ "$line" = "---GROUP---" ]; then
            CURRENT_GROUP="active"
            READING_FILES=false
            FILES=()
            continue
        fi

        if [ "$line" = "---END---" ]; then
            if [ "$CURRENT_GROUP" = "active" ] && [ ${#FILES[@]} -gt 0 ]; then
                COMMITS_CREATED=$((COMMITS_CREATED + 1))
                TOTAL_COMMITS=$((TOTAL_COMMITS + 1))
                log_step "Processing commit group $COMMITS_CREATED (total: $TOTAL_COMMITS)..."

                # Stage only the files in this group
                STAGED_COUNT=0
                for file in "${FILES[@]}"; do
                    # Skip empty lines
                    if [ -z "$file" ]; then
                        continue
                    fi

                    # Check if file exists (either tracked or untracked)
                    if [ -f "$file" ]; then
                        if git add "$file" 2>&1; then
                            log_info "  Staged: $file"
                            STAGED_COUNT=$((STAGED_COUNT + 1))
                        else
                            log_warning "  Failed to stage: $file"
                        fi
                    else
                        log_warning "  File not found: $file"
                    fi
                done

                if [ $STAGED_COUNT -eq 0 ]; then
                    log_warning "  No valid files staged for this group, skipping..."
                else
                    # Use single-commit to create the commit
                    if "$SINGLE_COMMIT"; then
                        LAST_COMMIT=$(git log -1 --pretty=format:"%s")
                        log_success "Created commit $TOTAL_COMMITS: $LAST_COMMIT"
                    else
                        log_error "Failed to create commit for group $COMMITS_CREATED"
                        # Unstage the files
                        git reset HEAD -- . 2>/dev/null || true
                        TOTAL_COMMITS=$((TOTAL_COMMITS - 1))
                    fi
                fi

                echo "" >&2
            fi

            CURRENT_GROUP=""
            READING_FILES=false
            FILES=()
            continue
        fi

        if [ "$CURRENT_GROUP" = "active" ]; then
            if [ "$line" = "FILES:" ]; then
                READING_FILES=true
                continue
            fi

            if [ "$READING_FILES" = true ] && [ -n "$line" ]; then
                FILES+=("$line")
            fi
        fi
    done <<< "$ANALYSIS"

    # Check if any commits were created in this iteration
    if [ $COMMITS_CREATED -eq 0 ]; then
        log_warning "No commits were created in iteration $ITERATION"
        exit 1
    fi

    log_info "Completed iteration $ITERATION with $COMMITS_CREATED commit(s)"

    # Loop will continue if there are still unstaged changes
done
